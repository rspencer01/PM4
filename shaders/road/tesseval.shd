#version 410 core

layout(triangles, equal_spacing, ccw) in;

uniform mat4 View;
uniform mat4 shadowProjection1;
uniform mat4 shadowProjection2;
uniform mat4 shadowProjection3;
uniform mat4 shadow1View;
uniform mat4 shadow2View;
uniform mat4 shadow3View;
out vec3 shadowPos1;
out vec3 shadowPos2;
out vec3 shadowPos3;
uniform mat4 projection;
uniform vec3 userCameraPosition;


in vec3 evaluationpoint_wor[];
in vec2 tc_uv[];
out vec3 pos;
out vec2 te_uv;
uniform sampler2D bumpmap;
uniform sampler2D heightmap;
uniform sampler2D noise;

void main()
{
    vec3 p0 = gl_TessCoord.x * evaluationpoint_wor[0];
    vec3 p1 = gl_TessCoord.y * evaluationpoint_wor[1];
    vec3 p2 = gl_TessCoord.z * evaluationpoint_wor[2];
    pos = p0+p1+p2;
    vec2 t0 = gl_TessCoord.x * tc_uv[0];
    vec2 t1 = gl_TessCoord.y * tc_uv[1];
    vec2 t2 = gl_TessCoord.z * tc_uv[2];
    te_uv = t0+t1+t2;
    vec4 disp = texture(bumpmap,te_uv)+texture(heightmap,(pos.xz+4000)/8000);
    float dist = length(userCameraPosition.xz - pos.xz);
    if (dist>10)
      disp.a+=atan((dist-10)/200)*0.5   ;
    pos.y += disp.a;
    
    vec4 shadowPos4 = shadowProjection1 * shadow1View * vec4(pos, 1.0);
    shadowPos1 = (shadowPos4.xyz / shadowPos4.w)/2+vec3(0.5);
    shadowPos4 = shadowProjection2 * shadow2View * vec4(pos, 1.0);
    shadowPos2 = (shadowPos4.xyz / shadowPos4.w)/2+vec3(0.5);
    shadowPos4 = shadowProjection3 * shadow3View * vec4(pos, 1.0);
    shadowPos3 = (shadowPos4.xyz / shadowPos4.w)/2+vec3(0.5);
    
    gl_Position = projection * View * vec4(pos, 1.0);
} 
