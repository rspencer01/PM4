#version 330
in vec3 position;
in vec3 normal;
in vec4 color;
in vec2 textcoord;
in mat4 model;

out VertexData
{
  vec4 position;
  vec4 normal;
  vec4 color;
  vec3 shadowPos1;
  vec3 shadowPos2;
  vec3 shadowPos3;
  vec2 uv;
  mat2 normMat;
} VertexOut;

uniform mat4 View;
uniform mat4 projection;
uniform mat4 shadowProjection1;
uniform mat4 shadowProjection2;
uniform mat4 shadowProjection3;
uniform vec3 CameraPosition;
uniform mat4 shadow1View;
uniform mat4 shadow2View;
uniform mat4 shadow3View;


void main()
{
  vec3 center = (model * vec4(0,0,0,1)).xyz;
  float rotation = 3.1415+atan(CameraPosition.x-center.x,CameraPosition.z-center.z);
  VertexOut.normMat = mat2(cos(rotation),-sin(rotation),sin(rotation),cos(rotation));
  
  VertexOut.position = model * vec4(position,1.0);
  VertexOut.position -= vec4(center,0);
  VertexOut.position.xz = VertexOut.normMat * VertexOut.position.xz;
  VertexOut.position += vec4(center,0);
  VertexOut.normal = model * vec4(normal,0);
  VertexOut.color = color;
  VertexOut.uv = textcoord;
  VertexOut.uv.x/=10;
  VertexOut.uv.x += 0.1 * int(rotation/(2*3.141592/10));

  vec4 temp = shadowProjection1 * shadow1View * VertexOut.position;
  VertexOut.shadowPos1 = (temp.xyz / temp.w)/2+vec3(0.5);
  temp = shadowProjection2 * shadow2View * VertexOut.position;
  VertexOut.shadowPos2 = (temp.xyz / temp.w)/2+vec3(0.5);
  temp = shadowProjection3 * shadow3View * VertexOut.position;
  VertexOut.shadowPos3 = (temp.xyz / temp.w)/2+vec3(0.5);

  gl_Position = projection * View * VertexOut.position;
}
