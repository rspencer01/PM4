#version 140
in vec4 pos;
uniform mat4 view;
uniform vec3 CameraPosition;
uniform vec3 sunDirection;
vec3 sunIntensity = vec3(10);
vec3 betar = vec3(5.5e-6,13.0e-6,22.4e-6);
vec3 betam = vec3(21e-6);

float Re = 6360e3;
float Ra = 6420e3;
float Hr = 8e3;
float Hm = 1.2e3;

vec3 calcTRal(vec3 Pa, vec3 Pb)
{
  float s = 0;
  int numInt = 20;
  float ds = length(Pb-Pa)/numInt;
  for (int i = 0;i<numInt;i++)
  {
    vec3 P = Pa + (Pb-Pa)/numInt*(i+1);
    float h = length(P) - Re;
    if (h<0) break;
    s += exp(-h/Hr)*ds;
  }
  return exp(-betar * s);
}

vec3 calcLR(vec3 P)
{
  float height = length(P);
  if (height<Re) return vec3(0.0);
  float theta = atan(sunDirection.y,length(sunDirection.xz));
  float r = -height*sin(theta) + sqrt(height*height*(sin(theta)*sin(theta)-1)+Ra*Ra);
  vec3 Ps = P + r * sunDirection; 
  return sunIntensity * calcTRal(P,Ps) * betar * exp(-(height-Re)/Hr);
}

vec3 calcLM(vec3 P)
{
  float height = length(P);
  if (height<Re) return vec3(0.0);
  float theta = atan(sunDirection.y,length(sunDirection.xz));
  float r = -height*sin(theta) + sqrt(height*height*(sin(theta)*sin(theta)-1)+Ra*Ra);
  vec3 Ps = P + r * sunDirection; 
  return sunIntensity * calcTRal(P,Ps) * betam * exp(-(height-Re)/Hm);
}

void main()
{
  vec3 direction = normalize(pos.xyz);
/*  if (direction.y<0)
  { 
    gl_FragColor = vec4(0,0,0,1);
    return;
  }*/
  if (dot(direction,sunDirection)>0.99995)
  {
    gl_FragColor = vec4(1);
    return;
  }
  float theta = atan(direction.y,length(direction.xz));
  float height = Re+CameraPosition.y;
  float r = -height*sin(theta) + sqrt(height*height*(sin(theta)*sin(theta)-1)+Ra*Ra);
  vec3 Pc = vec3(0,height,0); 
  vec3 Pa = Pc + direction * r; 

  vec3 color = vec3(0);
  int numInt = 20;
  float ds = r/numInt;
  float mu = dot(sunDirection,direction);
  float g = 0.76;
  float phaseR = 3.0/(16*3.141592)*(1+mu*mu);
  float phaseM = 3.0/(8*3.141592)*((1-g*g)*(1+mu*mu))/((2+g*g)*pow(1+g*g-2*g*mu,1.5));
  for (int i = 0;i<numInt;i++)
  {
    vec3 P = Pc + (Pa-Pc)/numInt*(i+1);

    color += calcTRal(Pc,P) * calcLR(P) * phaseR * ds;
    color += calcTRal(Pc,P) * calcLM(P) * phaseM * ds;
  }

  gl_FragColor = vec4(color,1);
}
