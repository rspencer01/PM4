#version 330
in vec4 pos;

layout(location=0) out vec4 fragColor;
layout(location=1) out vec4 fragNorm;

uniform mat4 View;
uniform vec3 CameraPosition;
uniform vec3 CameraDirection;
uniform vec3 sunDirection;
uniform float aspectRatio;
uniform sampler2D colormap;
uniform sampler2D depthmap;
uniform sampler2D opticaldepthmap;
uniform sampler2D nightSkymap;
vec3 sunIntensity = vec3(15);
vec3 betar = vec3(5.8e-6,1.35e-5,3.31e-5);
vec3 betam = vec3(21e-6);
vec3 offset = vec3(0,0,0.07);

float Re = 6360e3;
float Ra = 6420e3;
float Hr = 8e3;
float Hm = 1.2e3;
float INF = 1e20;
float g = 0.65;
int numInt = 50;

bool intersects(vec3 position, vec3 direction, float radius)
{
  if (dot(direction,position)*dot(direction,position) - dot(position,position)+radius*radius > 0)
    return true;
  return false;
}

float largestIntersectionDistance(vec3 position, vec3 direction, float radius)
{
  return - dot(position,direction) + 
            sqrt(dot(direction,position)*dot(direction,position) 
                 - dot(position,position)+radius*radius);
}

float smallestIntersectionDistance(vec3 position, vec3 direction, float radius)
{
  return - dot(position,direction) -
            sqrt(dot(direction,position)*dot(direction,position) 
                 - dot(position,position)+radius*radius);
}

void main()
{
  vec3 objectColor = textureLod(colormap,pos.xy/2+vec2(0.5),0).xyz; 
  float z_b = textureLod(depthmap,pos.xy/2+vec2(0.5),0).r;
  gl_FragDepth = clamp(z_b,0,0.9999);
  float z_n = 2*z_b - 1;
  float objectDepth = 2*0.3*8000/(8000+0.3-z_n*(8000-0.3));
  if (objectDepth > 7999.99)
  {
    objectDepth = INF;
  }

  vec3 right = vec3(View[0][0],View[1][0],View[2][0]);
  vec3 up = vec3(View[0][1],View[1][1],View[2][1]);
  vec3 forward = -vec3(View[0][2],View[1][2],View[2][2]);

  vec3 direction = normalize(forward + right * pos.x * aspectRatio * tan(3.141592/6) + up * pos.y * tan(3.141592/6));

  float sunTheta = atan(normalize(sunDirection).z,normalize(sunDirection).y); 
  vec3 celestialDirection = vec3(
                                direction.y*cos(sunTheta) + direction.z*sin(sunTheta),
                                direction.x,
                                direction.z*cos(sunTheta) - direction.y*sin(sunTheta));
  vec2 celestialMap;
  if (celestialDirection.y>0) 
  {
    celestialMap = normalize(vec2(celestialDirection.z,celestialDirection.x))*acos(celestialDirection.y)/3.141592*2;
    celestialMap = 0.25*celestialMap + vec2(0.25,0.5);
  }
  else
  {
    celestialMap = normalize(vec2(celestialDirection.z,celestialDirection.x))*acos(-celestialDirection.y)/3.141592*2;
    celestialMap = 0.25*celestialMap + vec2(0.75,0.5);
  }
  float celestialAmount = max(0,(0.4-dot(sunDirection,vec3(0,1,0)))/1.4);
  vec3 celestialColor = textureLod(nightSkymap,celestialMap,0).rgb * celestialAmount;
  if (objectDepth >= INF-1)
    objectColor = celestialColor;

  float theta = atan(direction.y,length(direction.xz));
  float lightTheta = atan(sunDirection.y,length(sunDirection.xz));

  float height = Re+CameraPosition.y;
  vec3 Pc = vec3(0,height,0); 
  float r = largestIntersectionDistance(Pc,direction,Ra);

  float r2 = smallestIntersectionDistance(Pc,direction,Ra);
  if (r2>0)
  {
    Pc = Pc + direction * r2;  
    r = largestIntersectionDistance(Pc,direction,Ra) - smallestIntersectionDistance(Pc,direction,Ra);
  }
  vec3 Pa = Pc + direction * r; 

  if (intersects(Pc,direction,Re))
  {
    if (smallestIntersectionDistance(Pc,direction,Re) > 0)
    { 
      Pa = vec3(0,height,0) + direction * smallestIntersectionDistance(Pc,direction,Re);
    }
  }

  if (length(Pa - vec3(0,height,0)) > objectDepth)
  {
    Pa = vec3(0,height,0) + objectDepth * direction;
  }

  float mu = dot(normalize(sunDirection),normalize(direction));
  float phaseR = 3.0/(16*3.141592)*(1+mu*mu);
  float phaseM = 3.0/(8*3.141592)*((1-g*g)*(1+mu*mu))/((2+g*g)*pow(1+g*g-2*g*mu, 1.5));

  vec3 raleigh = vec3(0);
  vec3 mie = vec3(0);

  float opticalDepthR = 0;
  float opticalDepthM = 0;

  float ds = length(Pa - Pc) / numInt;

  for (int i = 1;i<numInt;i++)
  {
    vec3 P = mix(Pc,Pa,float(i)/numInt);
    float lightHeight = length(P) - Re;
    if (lightHeight < 0) break;
    float lightR = largestIntersectionDistance(P,sunDirection,Ra);
    vec3 Ps = P + lightR * sunDirection; 

    float hr = exp(-lightHeight/Hr) * ds;
    float hm = exp(-lightHeight/Hm) * ds;

    opticalDepthR += hr;
    opticalDepthM += hm;
   
    //Decomment if you want the non texture stuff 
    float opticalDepthLightR = 0;
    float opticalDepthLightM = 0;
    float opticalDepthDs = lightR/numInt;
  /*
    int j = numInt;
    for (j = 0;j<numInt;j++)
    {
      vec3 Pq = mix(P,Ps,float(j)/numInt);
      float h = length(Pq) - Re;
      if (h<0) break;
      opticalDepthLightR += exp(-h/Hr)*opticalDepthDs;
      opticalDepthLightM += exp(-h/Hm)*opticalDepthDs;
    }
    */
    vec2 xx = vec2(acos(dot(sunDirection,normalize(P)))/(3.141592*0.75),pow((length(P)-Re)/(Ra-Re),0.33333)); 
    if (xx.x<0 || xx.x>1) continue;
    //if (direction.x>0){
    opticalDepthLightR = vec3(textureLod(opticaldepthmap,xx.xy,0).r);
    opticalDepthLightM = vec3(textureLod(opticaldepthmap,xx.xy,0).g);
    //}if (j==numInt || opticalDepthLightR >= 0)
    if (opticalDepthLightR >= 0 && opticalDepthLightM >=0)
    {
      vec3 tau = betar * (vec3(opticalDepthLightR) + opticalDepthR) + betam * 1.1 * (vec3(opticalDepthLightM) + opticalDepthM);

      raleigh += exp(-tau) * hr;
      mie += exp(-tau) * hm;
    }
  }
  raleigh *= phaseR * betar;
  mie *= phaseM * betam;

  vec3 atmosphereColor = sunIntensity*(raleigh + mie) + offset;

  if (objectDepth > 7999.99)
    if (mu > 0.99995792)
      atmosphereColor = sunIntensity * exp(-opticalDepthR * betar);
  fragColor = vec4(atmosphereColor + objectColor, 1);
  fragNorm = vec4(0);
}
