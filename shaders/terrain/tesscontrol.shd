#version 410 core

// define the number of CPs in the output patch
layout (vertices = 3) out;

// The rendering camera (could be shadow)
uniform vec3 CameraPosition;
uniform vec3 CameraDirection;
// The user camera
uniform vec3 userCameraPosition;
uniform vec3 userCameraDirection;
uniform int shadowLevel;

in vec3 pos[];

out vec3 evaluationpoint_wor[];
out vec4 shadowPosFS[];

uniform sampler2D heightmap;
uniform sampler2D noise;

int detailLevel(vec3 position)
{
  float dist = length(userCameraPosition.xz - position.xz);
  if (dist < 200)
    return 100;
  if (dot(normalize(position-userCameraPosition),normalize(userCameraDirection)) < 0.3)
    return 0;
  vec3 norm = normalize(texture(heightmap,(position.xz+4000)/8000).xyz);
  int normMod = clamp(
      int(20.0*(1-dot(norm,vec3(0,1.0,0)))),
      1,22);
  return clamp(
  int(clamp(80*(1-dist/700),1,100))  + normMod
  ,1,100);
} 


void main()
{
    // Set the control points of the output patch
    //TexCoord_ES_in[gl_InvocationID] = TexCoord_CS_in[gl_InvocationID];
    //Normal_ES_in[gl_InvocationID] = Normal_CS_in[gl_InvocationID];
    evaluationpoint_wor[gl_InvocationID] = pos[gl_InvocationID];

    // Calculate the tessellation levels
  gl_TessLevelInner[0] = detailLevel((pos[0]+pos[1]+pos[2])/3.0);
  gl_TessLevelOuter[0] = detailLevel((pos[1]+pos[2])/2.0);
  gl_TessLevelOuter[1] = detailLevel((pos[0]+pos[2])/2.0);
  gl_TessLevelOuter[2] = detailLevel((pos[1]+pos[0])/2.0);
} 
