#version 410 core

layout(triangles, equal_spacing, ccw) in;

uniform mat4 View;
uniform mat4 projection;
uniform mat4 shadowProjection1;
uniform mat4 shadowProjection2;
uniform mat4 shadowProjection3;
uniform mat4 shadow1View;
uniform mat4 shadow2View;
uniform mat4 shadow3View;
uniform sampler2D heightmap;
uniform sampler2D noise;

in vec3 evaluationpoint_wor[];

out TesselationData
{
  vec4 position;
  vec4 origPosition;
  vec3 shadowPos1;
  vec3 shadowPos2;
  vec3 shadowPos3;
} TesselationOut;

vec4 scaleT(vec4 v,float f)
{
  return vec4(normalize(vec3(v.x,v.y/f,v.z)),v.w*f);
}

float getCurvature()
{
  float c = texture(heightmap,TesselationOut.position.xz/8000+vec2(0.5)).a;
  float d = texture(heightmap,(TesselationOut.position.xz+vec2(16,0))/8000+vec2(0.5)).a+
            texture(heightmap,(TesselationOut.position.xz+vec2(0,16))/8000+vec2(0.5)).a+
            texture(heightmap,(TesselationOut.position.xz+vec2(-16,0))/8000+vec2(0.5)).a+
            texture(heightmap,(TesselationOut.position.xz+vec2(0,-16))/8000+vec2(0.5)).a;
  d/=4;
  return abs(c-d);
}

float getFineAmount()
{
  float theta = acos(normalize(texture(heightmap,TesselationOut.position.xz/8000+vec2(0.5)).xyz).y);
  if (theta<0.5)
    return 1+2*getCurvature();;
  theta = (theta -0.5)/(3.1415/2 - 0.5);
  return (theta*20+1) + 2*getCurvature();
}

void main()
{
  vec3 p0 = gl_TessCoord.x * evaluationpoint_wor[0];
  vec3 p1 = gl_TessCoord.y * evaluationpoint_wor[1];
  vec3 p2 = gl_TessCoord.z * evaluationpoint_wor[2];
  TesselationOut.position = vec4(p0+p1+p2,1);
  TesselationOut.position.y += 1e3;
  TesselationOut.origPosition = TesselationOut.position;
  vec3 displacement = vec3(0,1,0) * texture(heightmap,(TesselationOut.position.xyz+vec3(4000)).xz/8000).a;
  vec3 normal = texture(heightmap,(TesselationOut.position.xyz+vec3(4000)).xz/8000).zyx;
  normal = normalize(normal);

  displacement += normal * getFineAmount() * texture(noise,TesselationOut.position.xz/200).a;

  TesselationOut.position.xyz += displacement;

  vec4 temp = shadowProjection1 * shadow1View * TesselationOut.position;
  TesselationOut.shadowPos1 = (temp.xyz / temp.w)/2+vec3(0.5);
  temp = shadowProjection2 * shadow2View * TesselationOut.position;
  TesselationOut.shadowPos2 = (temp.xyz / temp.w)/2+vec3(0.5);
  temp = shadowProjection3 * shadow3View * TesselationOut.position;
  TesselationOut.shadowPos3 = (temp.xyz / temp.w)/2+vec3(0.5);

  gl_Position = projection * View * TesselationOut.position;
} 
