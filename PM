#!/usr/bin/python
import sys
import time
import logging
from transforms import *
import numpy as np
import numpy.linalg
import taskQueue
import OpenGL.GL as gl
import OpenGL.GLU as glu
import OpenGL.GLUT as glut
import OpenGL.GL.framebufferobjects as glfbo
import Image
logging.basicConfig(format ='%(asctime)-15s <%(threadName)-12s> [%(module)-12s] - %(message)s',level=logging.INFO)

import args
args.parse()

import configuration

Re = 6.360e6

program = None
windowHeight = 512
windowWidth = 512
line = False
cameraSpeed = 20
frametime = 0.
lastframe = time.time()
enableAtmosphere = not args.args.disable_atmosphere
screenshotDest = None
hold_mouse = True
fastMode = False

aboveGround = 1

def display():
  global frametime,lastframe,cputime,lastcpucycle, screenshotDest
  frametime = frametime*.8 + 0.2*(time.time()-lastframe)
  lastframe = time.time()

  global cameraSpeed

  p = camera.position + np.array([0,Re,0])
  if fastMode:
    cameraSpeed = max((p.dot(p)**0.5-Re-1000)*3+90,0)
  else:
    cameraSpeed = max((p.dot(p)**0.5-Re-1000)*.1+90,0)
  f = np.clip((p.dot(p)**0.5 - Re*1.03) /(Re*0.3),0,1)
  globUp = np.array([np.array([1.0,0.0,0.0]),
                     p/p.dot(p)**0.5])
  camera.globalUp = (globUp[0]*f + globUp[1]*(1-f))
  camera.globalUp /= camera.globalUp.dot(camera.globalUp)**0.5
  t = np.cross(camera.globalUp,camera.globalRight)
  camera.globalRight = np.cross(t,camera.globalUp)
  camera.globalRight /= camera.globalRight.dot(camera.globalRight)**0.5

  Terrain.updatePageTable(camera)

  camera.render('user')
  Shadows.render()

  if line:
    gl.glPolygonMode(gl.GL_FRONT_AND_BACK,gl.GL_LINE)
  renderStages[0].load(windowWidth, windowHeight)

  camera.render()
  projection = perspective( 60.0, windowWidth/float(windowHeight), 0.3, 1e7 )
  updateUniversalUniform('projectionNear', 0.3)
  updateUniversalUniform('projectionFar', 1e7)
  setUniform('projection', projection)
  setUniform('aspectRatio', windowWidth/float(windowHeight))
  setUniform('windowWidth', float(windowWidth))

  camera.render()
  camera.render('user')
  Terrain.display(camera)
  Characters.display(camera)
  Buildings.display(camera)
  grass.display(camera)
  Forest.display(camera.position)

  gl.glPolygonMode(gl.GL_FRONT_AND_BACK,gl.GL_FILL);
  renderStages[1].load(windowWidth, windowHeight)
  postrender.lighting(renderStages[0].displayColorTexture,renderStages[0].displaySecondaryColorTexture,renderStages[0].displayAuxColorTexture,renderStages[0].displayDepthTexture)
  lastRenderStage = renderStages[1]

  if enableAtmosphere:
    renderStages[2].load(windowWidth, windowHeight)
    Sky.display(lastRenderStage)
    lastRenderStage = renderStages[2]

  renderStages[3].load(windowWidth, windowHeight)
  postrender.display(lastRenderStage,windowWidth,windowHeight)
  Map.display()
  lastRenderStage = renderStages[3]

  glut.glutSwapBuffers()
  glut.glutSetWindowTitle("PM4 {:.2f} ({:.0f}ms) {:.6f}".format(1./frametime,frametime*1000, time.time()-lastframe))

  if screenshotDest:
      takeScreenshot(lastRenderStage)

def takeScreenshot(renderStage):
  global screenshotDest
  pixels = gl.glReadPixels(0, 0, renderStage.width, renderStage.height, gl.GL_RGB, gl.GL_UNSIGNED_BYTE)

  image = Image.fromstring("RGB", (renderStage.width, renderStage.height), pixels)
  image = image.transpose( Image.FLIP_TOP_BOTTOM)
  image.save(screenshotDest if type(screenshotDest) == str else "screenshot.png")
  # Do a nice flash effect
  postrender.exposure = 5
  screenshotDest = None


def timer(fps):
#  Marker.timeUpdate(1.0/fps)
  Map.update(1.0/fps)
  if 'w' in keys:
    camera.move(cameraSpeed * 1.0/fps)
    if camera.lockObject:
      Characters.setCharacterDirection(camera.direction)
      Characters.move(0.5)
  if 's' in keys:
    camera.move(cameraSpeed * -1.0/fps)
    if camera.lockObject:
      Characters.setCharacterDirection(camera.direction)
      Characters.move(-0.5)
  if 'e' in keys:
    camera.rotUpDown(1.5/fps)
  if 'q' in keys:
    camera.rotUpDown(-1.5/fps)
  if 'a' in keys:
    camera.rotLeftRight(-1.5/fps)
  if 'd' in keys:
    camera.rotLeftRight(1.5/fps)
  if 'h' in keys:
    camera.position = camera.position * 0.98

  taskQueue.doNextTask()

  glut.glutTimerFunc(1000/fps, timer, fps)
  glut.glutPostRedisplay()

def mouseMotion(x,y):
  if x != windowWidth/2 or \
     y != windowHeight/2:
    if hold_mouse:
      camera.rotUpDown(0.01*(y-windowHeight/2.))
      camera.rotLeftRight(0.01*(x-windowWidth/2.))
      glut.glutWarpPointer(windowWidth/2,windowHeight/2)

def reshape(width,height):
  global windowHeight,windowWidth
  windowHeight = height
  windowWidth = width
  for stage in renderStages:
    stage.reshape(width, height)

keys = set()
def keyboard(key,x,y):
  global line,enableAtmosphere, screenshotDest, hold_mouse, fastMode
  if key=='\033':
    sys.exit(0)
  if key=='l':
    if camera.lockObject:
      camera.lockObject = None
    else:
      camera.lockObject = Characters.character
  if key=='~':
    userCommand()
  if key=='p':
    line = not line
  if key=='#':
    reload(Map)
  if key=='o':
    enableAtmosphere = not enableAtmosphere
  if key=='t':
    screenshotDest = True
  if key=='f':
    fastMode = not fastMode
  if key=='m':
    Map.targetFullScreenAmount = 1-Map.targetFullScreenAmount
  if key=='n':
    postrender.showNormals = (postrender.showNormals + 1) % 3
  if key=='r':
    if hold_mouse:
      glut.glutSetCursor(glut.GLUT_CURSOR_INHERIT)
    else:
      glut.glutSetCursor(glut.GLUT_CURSOR_NONE)
    hold_mouse = not hold_mouse
  if key=='?':
    print open('help').read()
  keys.add(key)

def keyboardUp(key,x,y):
  if key in keys:
    keys.remove(key)

def mouse(button,state,x,y):
  if button in (3,4):
    camera.lockDistance += button - 3.5
  if not hold_mouse:
    glut.glutWarpPointer(windowWidth/2,windowHeight/2)

def accio():
  Characters.character.position = camera.position.copy()

def horse(i=0):
  camera.position = Buildings.clumpSpecs[i].position
  accio()
  Characters.move(0)

def userCommand():
  command = raw_input('>>> ')
  while (command not in ['continue','exit']):
    try:
      exec(command,globals())
    except Exception as e:
      print "Exception:",e
    command = raw_input('>>> ')

glut.glutInit()
logging.info("Requesting OpenGL 4.2")
glut.glutInitContextVersion(4, 2);
glut.glutInitContextFlags(glut.GLUT_FORWARD_COMPATIBLE);
glut.glutInitContextProfile(glut.GLUT_CORE_PROFILE);
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutInitWindowSize(512,512);
glut.glutCreateWindow("PM4")
logging.info("Obtained OpenGL "+gl.glGetString(gl.GL_VERSION))
logging.info("Uniform limit (vertex) {}".format(
  str(gl.glGetIntegerv(gl.GL_MAX_VERTEX_UNIFORM_COMPONENTS))))
gl.glEnable(gl.GL_DEPTH_TEST)
gl.glPolygonMode(gl.GL_FRONT_AND_BACK,gl.GL_FILL);
gl.glEnable(gl.GL_BLEND)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA);
glut.glutReshapeFunc(reshape)
glut.glutDisplayFunc(display)
glut.glutKeyboardFunc(keyboard)
glut.glutMouseFunc(mouse)
glut.glutKeyboardUpFunc(keyboardUp)
glut.glutTimerFunc(1000/60, timer, 60)
glut.glutPassiveMotionFunc(mouseMotion)
glut.glutSetCursor(glut.GLUT_CURSOR_NONE)

import RenderStage

from Shaders import *
import Camera
import Texture
#import Marker
import Terrain
import noiseG
#import Road
import Forest

import postrender
import Sky
import Shadows
import grass
import Characters
import Buildings
import Map

camera = Camera.Camera(
        np.array([ 654., 1356.92767998,-120]),
        move_hook=lambda x:np.array((x[0],
            max(Terrain.getAt(x[0],x[2])+0.6,x[1]),x[2]))
        )
camera.radiusCentre = np.array([0,-Re,0])
camera.minRadius = Re
camera.render()
Shadows.shadowCamera.lockObject = camera
#for i in xrange(-10,10):
#  for j in xrange(-10,10):
#    Marker.addMarker(400*np.array([i,0,j]))
#Marker.freeze()

renderStages = [RenderStage.RenderStage(),
                RenderStage.RenderStage(),
                RenderStage.RenderStage(),
                RenderStage.RenderStage(final_stage=True)
                ]
logging.info("Initialisation finished")
glut.glutMainLoop()
