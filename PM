#!/usr/bin/python
import sys
import time
import logging
from transforms import *
import numpy as np
import numpy.linalg
import taskQueue
import OpenGL.GL as gl
import OpenGL.GLU as glu
import OpenGL.GLUT as glut
import OpenGL.GL.framebufferobjects as glfbo
import Image
import messaging
import random

import args
args.parse()

LOGGING_FORMAT = '%(asctime)-15s <%(threadName)-12s> [%(module)-12s] - %(message)s'
if args.args.verbose:
  logging.basicConfig(format=LOGGING_FORMAT, level=logging.DEBUG)
else:
  logging.basicConfig(format=LOGGING_FORMAT, level=logging.INFO)

import configuration

Re = 6.360e6

program = None
windowHeight = 512
windowWidth = 512
line = False
cameraSpeed = 20
frametime = 0.
lastframe = time.time()
enableAtmosphere = not args.args.disable_atmosphere
screenshotDest = None
hold_mouse = True
fastMode = False
trianglesQuery = None
flycamactive = False
frametimes = [0 for _ in xrange(200)]
frametimecount = 0

aboveGround = 1

def display():
  global frametime,lastframe,cputime,lastcpucycle, screenshotDest, trianglesQuery, frametimes, frametimecount
  thisframetime = time.time()-lastframe
  frametimes[frametimecount % len(frametimes)] = thisframetime
  frametimecount += 1
  frametime = frametime*.8 + 0.2*thisframetime
  lastframe = time.time()

  messaging.process_messages()

  if not trianglesQuery:
    trianglesQuery = gl.glGenQueries(1)
  gl.glBeginQuery(gl.GL_PRIMITIVES_GENERATED, trianglesQuery)

  global cameraSpeed

  p = camera.position + np.array([0,Re,0])
  if fastMode:
    cameraSpeed = max((p.dot(p)**0.5-Re-1000)*3+90,0)
  else:
    cameraSpeed = max((p.dot(p)**0.5-Re-1000)*.1+90,0)
  f = np.clip((p.dot(p)**0.5 - Re*1.03) /(Re*0.3),0,1)
  globUp = np.array([np.array([1.0,0.0,0.0]),
                     p/p.dot(p)**0.5])
  camera.globalUp = (globUp[0]*f + globUp[1]*(1-f))
  camera.globalUp /= camera.globalUp.dot(camera.globalUp)**0.5
  t = np.cross(camera.globalUp,camera.globalRight)
  camera.globalRight = np.cross(t,camera.globalUp)
  camera.globalRight /= camera.globalRight.dot(camera.globalRight)**0.5

  Terrain.updatePageTable(camera)

  gl.glEnable(gl.GL_CULL_FACE)
  camera.render('user')
  Shadows.render()

  if line:
    gl.glPolygonMode(gl.GL_FRONT_AND_BACK,gl.GL_LINE)
  renderStages[0].load(windowWidth, windowHeight)

  camera.render()
  projection = perspective( 60.0, windowWidth/float(windowHeight), 0.3, 1e7 )
  updateUniversalUniform('projectionNear', 0.3)
  updateUniversalUniform('projectionFar', 1e7)
  setUniform('projection', projection)
  setUniform('aspectRatio', windowWidth/float(windowHeight))
  setUniform('windowWidth', float(windowWidth))

  camera.render()
  camera.render('user')
  Terrain.display(camera)
  Characters.display(camera)
  Buildings.display(camera)
  grass.display(camera)
  Forest.display(camera.position)

  particles.render_all()

  gl.glDisable(gl.GL_CULL_FACE)
  gl.glPolygonMode(gl.GL_FRONT_AND_BACK,gl.GL_FILL);
  renderStages[1].load(windowWidth, windowHeight)
  postrender.lighting(renderStages[0].displayColorTexture,renderStages[0].displaySecondaryColorTexture,renderStages[0].displayAuxColorTexture,renderStages[0].displayDepthTexture)
  lastRenderStage = renderStages[1]

  if enableAtmosphere:
    renderStages[2].load(windowWidth, windowHeight)
    Sky.display(lastRenderStage)
    lastRenderStage = renderStages[2]

  renderStages[3].load(windowWidth, windowHeight)
  postrender.display(lastRenderStage,windowWidth,windowHeight)
  Map.display()
  lastRenderStage = renderStages[3]

  gl.glEndQuery(gl.GL_PRIMITIVES_GENERATED)
  triangleCount = gl.glGetQueryObjectiv(trianglesQuery, gl.GL_QUERY_RESULT)

  glut.glutSwapBuffers()
  glut.glutSetWindowTitle("PM4 {:.2f} ({:.0f}ms) {:.6f} {:,} triangles".format(1./frametime,frametime*1000, time.time()-lastframe, triangleCount))
  glut.glutPostRedisplay()

  if screenshotDest:
      takeScreenshot(lastRenderStage)

def takeScreenshot(renderStage):
  global screenshotDest
  pixels = gl.glReadPixels(0, 0, renderStage.width, renderStage.height, gl.GL_RGB, gl.GL_UNSIGNED_BYTE)

  image = Image.fromstring("RGB", (renderStage.width, renderStage.height), pixels)
  image = image.transpose( Image.FLIP_TOP_BOTTOM)
  image.save(screenshotDest if type(screenshotDest) == str else "screenshot.png")
  # Do a nice flash effect
  postrender.exposure = 5
  screenshotDest = None

def glut_timer_handler(fps):
  messaging.add_message(messaging.Message('timer', (fps,)))

def timer_handler(fps):
#  Marker.timeUpdate(1.0/fps)
  Map.update(1.0/fps)
  particles.update(Shadows.gameTime)
  Forest.update(camera.position)
  Characters.update()
  if flycamactive:
    flyCam.update(camera)
  Shadows.gameTime += 3e-4
  if 'w' in keys:
    camera.move(cameraSpeed * 1.0/fps)
    if camera.lockObject:
      Characters.setCharacterDirection(camera.direction)
      Characters.move(0.5)
  if 's' in keys:
    camera.move(cameraSpeed * -1.0/fps)
    if camera.lockObject:
      Characters.setCharacterDirection(camera.direction)
      Characters.move(-0.5)
  if 'e' in keys:
    camera.rotUpDown(1.5/fps)
  if 'q' in keys:
    camera.rotUpDown(-1.5/fps)
  if 'a' in keys:
    camera.rotLeftRight(-1.5/fps)
  if 'd' in keys:
    camera.rotLeftRight(1.5/fps)
  if 'h' in keys:
    camera.position = camera.position * 0.98

  taskQueue.doNextTask()

  glut.glutTimerFunc(1000/fps, glut_timer_handler, fps)

def mouse_motion_handler(x, y):
  if x != windowWidth/2 or \
     y != windowHeight/2:
    if hold_mouse:
      camera.rotUpDown(0.01*(y-windowHeight/2.))
      camera.rotLeftRight(0.01*(x-windowWidth/2.))
      glut.glutWarpPointer(windowWidth/2,windowHeight/2)

def reshape(width,height):
  global windowHeight,windowWidth
  windowHeight = height
  windowWidth = width
  for stage in renderStages:
    stage.reshape(width, height)

keys = set()
def keyboard_handler(key, x, y):
  global line,enableAtmosphere, screenshotDest, hold_mouse, fastMode,flycamactive
  if key=='\033':
    if args.args.replay is None:
      messaging.save_messages()
    gl.glDeleteQueries(1, [trianglesQuery])
    logging.info("Average frame time {:.4f} (+-{:.4f})".format(sum(frametimes)/len(frametimes), np.std(frametimes)))
    logging.warn("Exiting...")
    sys.exit(0)
  if key=='l':
    if camera.lockObject:
      camera.lockObject = None
    else:
      camera.lockObject = Characters.character
  if key=='~':
    if args.args.replay is None:
      userCommand()
  if key=='p':
    line = not line
  if key=='#':
    reload(Terrain)
  if key=='o':
    enableAtmosphere = not enableAtmosphere
  if key=='t':
    screenshotDest = True
  if key=='f':
    fastMode = not fastMode
  if key=='0':
    messaging.add_message(messaging.Message('add_light',()))
  if key=='m':
    Map.targetFullScreenAmount = 1-Map.targetFullScreenAmount
  if key=='n':
    postrender.showNormals = (postrender.showNormals + 1) % 3
  if key=='z':
    messaging.add_message(messaging.Message('spell',('idea',)))
  if key=='Z':
    messaging.add_message(messaging.Message('spell',('fountain',)))
  if key=='y':
    flycamactive = not flycamactive
  if key=='r':
    if hold_mouse:
      glut.glutSetCursor(glut.GLUT_CURSOR_INHERIT)
    else:
      glut.glutSetCursor(glut.GLUT_CURSOR_NONE)
    hold_mouse = not hold_mouse
  if key=='?':
    print open('help').read()
  keys.add(key)

def keyboard_up_handler(key,x,y):
  if key in keys:
    keys.remove(key)

def mouse_handler(button, state, x, y):
  if button in (3,4):
    camera.lockDistance += button - 3.5
  if not hold_mouse:
    glut.glutWarpPointer(windowWidth/2,windowHeight/2)

def glut_keyboard_handler(key, x, y):
  messaging.add_message(messaging.Message('keyboard',(key, x, y)))

def glut_keyboard_up_handler(key, x, y):
  messaging.add_message(messaging.Message('keyboard_up',(key, x, y)))

def glut_mouse_handler(button, state, x, y):
  messaging.add_message(messaging.Message('mouse',(button, state, x, y)))

def glut_mouse_motion_handler(x, y):
  messaging.add_message(messaging.Message('mouse_motion',(x, y)))

def horse(i=0):
  messaging.add_message(messaging.Message('horse',(i,)))

def accio():
  messaging.add_message(messaging.Message('accio',()))

def game_start_handler(time):
  logging.info("Game start!")
  glut.glutTimerFunc(1000/60, glut_timer_handler, 60)

def accio_handler():
  Characters.character.position = camera.position.copy()

def horse_handler(i):
  camera.position = Buildings.clumpSpecs[i].position
  camera.update()
  accio()
  Characters.move(0)

def add_light_handler():
  lighting.addLight(Characters.character.position, 
      [random.random()*0.5+0.5, random.random()*0.5+0.5, random.random()*0.5+0.5])

def spell_handler(type):
  if type == 'idea':
    particles.add_system(spells.IdeaSpellParticles(Characters.character.position[:]))
  elif type == 'fountain':
    particles.add_system(spells.FountainSpellParticles(Characters.character.position[:]))
  else:
    logging.warn('Unknown spell "{}"'.format(type))


def userCommand():
  command = raw_input('>>> ')
  while (command not in ['continue','exit']):
    try:
      exec(command,globals())
    except Exception as e:
      print "Exception:",e
    command = raw_input('>>> ')

glut.glutInit()
logging.info("Requesting OpenGL 4.2")
glut.glutInitContextVersion(4, 2);
glut.glutInitContextFlags(glut.GLUT_FORWARD_COMPATIBLE);
glut.glutInitContextProfile(glut.GLUT_CORE_PROFILE);
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutInitWindowSize(512,512);
glut.glutCreateWindow("PM4")
glut.glutSetKeyRepeat(glut.GLUT_KEY_REPEAT_OFF)
logging.info("Obtained OpenGL "+gl.glGetString(gl.GL_VERSION))
logging.info("Uniform limit (vertex) {}".format(
  str(gl.glGetIntegerv(gl.GL_MAX_VERTEX_UNIFORM_COMPONENTS))))
gl.glEnable(gl.GL_DEPTH_TEST)
gl.glPolygonMode(gl.GL_FRONT_AND_BACK,gl.GL_FILL);
gl.glEnable(gl.GL_BLEND)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA);
gl.glCullFace(gl.GL_BACK)
glut.glutReshapeFunc(reshape)
glut.glutDisplayFunc(display)
if args.args.replay is None:
  glut.glutMouseFunc(glut_mouse_handler)
  glut.glutPassiveMotionFunc(glut_mouse_motion_handler)
  glut.glutKeyboardFunc(glut_keyboard_handler)
  glut.glutKeyboardUpFunc(glut_keyboard_up_handler)
glut.glutSetCursor(glut.GLUT_CURSOR_NONE)

import RenderStage

from Shaders import *
import Camera
import Texture
#import Marker
import Terrain
import noiseG
#import Road
import Forest

import postrender
import lighting
import particles
import spells
import Sky
import Shadows
import grass
import Characters
import Buildings
import Map

import flyCam

camera = Camera.Camera(
        np.array([ 0., 1356.92767998,-1000]),
        move_hook=lambda x:np.array((x[0],
            max(Terrain.getAt(x[0],x[2])+0.6,x[1]),x[2]))
        )
camera.radiusCentre = np.array([0,-Re,0])
camera.minRadius = Re
camera.render()
Shadows.shadowCamera.lockObject = camera
#for i in xrange(-10,10):
#  for j in xrange(-10,10):
#    Marker.addMarker(400*np.array([i,0,j]))
#Marker.freeze()

renderStages = [RenderStage.RenderStage(),
                RenderStage.RenderStage(),
                RenderStage.RenderStage(),
                RenderStage.RenderStage(final_stage=True)
                ]

messaging.add_handler('mouse', mouse_handler)
messaging.add_handler('mouse_motion', mouse_motion_handler)
messaging.add_handler('keyboard', keyboard_handler)
messaging.add_handler('keyboard_up', keyboard_up_handler)
messaging.add_handler('timer', timer_handler)
messaging.add_handler('game_start', game_start_handler)
messaging.add_handler('horse', horse_handler)
messaging.add_handler('accio', accio_handler)
messaging.add_handler('add_light', add_light_handler)
messaging.add_handler('spell', spell_handler)

logging.info("Initialisation finished")
messaging.add_message(messaging.Message('game_start', (time.time(),)))
if args.args.replay:
  messaging.load_replay(args.args.replay)
glut.glutMainLoop()
