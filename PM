#!/usr/bin/python
import sys
import time
import logging
from transforms import *
import numpy as np
import numpy.linalg
import taskQueue
import OpenGL.GL as gl
import OpenGL.GLU as glu
import OpenGL.GLUT as glut
import OpenGL.GL.framebufferobjects as glfbo
logging.basicConfig(format ='%(asctime)-15s <%(threadName)-12s> [%(module)-12s] - %(message)s',level=logging.INFO)

import args
args.parse()

Re = 6.360e6

program = None
windowHeight = 512
windowWidth = 512
lockToGround = False
line = False
cameraSpeed = 20
frametime = 0.
lastframe = time.time()
enableAtmosphere = not args.args.disable_atmosphere

aboveGround = 1

def display():
  global frametime,lastframe,cputime,lastcpucycle
  frametime = frametime*.8 + 0.2*(time.time()-lastframe)
  lastframe = time.time()

  if lockToGround:
    camera.pos[1] = Terrain.getAt(camera.pos[0],camera.pos[2])[3]+aboveGround

  global cameraSpeed

  p = camera.pos + np.array([0,Re,0])
  cameraSpeed = max((p.dot(p)**0.5-Re-1000)*2+90,0)
  f = np.clip((p.dot(p)**0.5 - Re*1.03) /(Re*0.3),0,1)
  globUp = np.array([np.array([1.0,0.0,0.0]),
                     p/p.dot(p)**0.5])
  camera.globalUp = (globUp[0]*f + globUp[1]*(1-f))
  camera.globalUp /= camera.globalUp.dot(camera.globalUp)**0.5
  t = np.cross(camera.globalUp,camera.globalRight)
  camera.globalRight = np.cross(t,camera.globalUp)
  camera.globalRight /= camera.globalRight.dot(camera.globalRight)**0.5

  Terrain.updatePageTable(camera)

  camera.render('user')
  Shadows.render()

  if line:
    gl.glPolygonMode(gl.GL_FRONT_AND_BACK,gl.GL_LINE)
  renderStages[0].load(windowWidth, windowHeight)

  camera.render()
  projection = perspective( 60.0, windowWidth/float(windowHeight), 0.3, 1e7 )
  setUniform('projection',projection)
  setUniform('aspectRatio',windowWidth/float(windowHeight))
  setUniform('windowWidth',float(windowWidth))

  camera.render()
  camera.render('user')
  Terrain.display(camera)
  #grass.display(camera)
  #Forest.display(camera.pos)

  gl.glPolygonMode(gl.GL_FRONT_AND_BACK,gl.GL_FILL);
  renderStages[1].load(windowWidth, windowHeight)
  postrender.lighting(renderStages[0].displayColorTexture,renderStages[0].displaySecondaryColorTexture,renderStages[0].displayAuxColorTexture,renderStages[0].displayDepthTexture)
  lastRenderStage = renderStages[1]

  if enableAtmosphere:
    renderStages[2].load(windowWidth, windowHeight)
    Sky.display(lastRenderStage)
    lastRenderStage = renderStages[2]

  renderStages[3].load(windowWidth, windowHeight)
  postrender.display(lastRenderStage,windowWidth,windowHeight)
  lastRenderStage = renderStages[3]

  glut.glutSwapBuffers()
  glut.glutSetWindowTitle("PM4 {:.2f} ({:.0f}ms) {:.6f}".format(1./frametime,frametime*1000, time.time()-lastframe))

def timer(fps):
#  Marker.timeUpdate(1.0/fps)
  if 'w' in keys:
    camera.move(cameraSpeed * 1.0/fps)
  if 's' in keys:
    camera.move(cameraSpeed * -1.0/fps)
  if 'e' in keys:
    camera.rotUpDown(1.5/fps)
  if 'q' in keys:
    camera.rotUpDown(-1.5/fps)
  if 'a' in keys:
    camera.rotLeftRight(-1.5/fps)
  if 'd' in keys:
    camera.rotLeftRight(1.5/fps)
  if 'h' in keys:
    camera.pos = camera.pos * 0.98

  taskQueue.doNextTask()

  glut.glutTimerFunc(1000/fps, timer, fps)
  glut.glutPostRedisplay()

mouseX,mouseY = 0,0
def mouseMotion(x,y):
  global mouseX,mouseY
  camera.rotUpDown(0.01*(y-mouseY))
  camera.rotLeftRight(0.01*(x-mouseX))
  mouseX = x
  mouseY = y

def reshape(width,height):
  global windowHeight,windowWidth
  windowHeight = height
  windowWidth = width
  for stage in renderStages:
    stage.reshape(width, height)

keys = set()
def keyboard(key,x,y):
  global line,enableAtmosphere
  if key=='\033':
    #    Shadows.cleanup()
    sys.exit(0)
  if key=='l':
    global lockToGround
    lockToGround = not lockToGround
  if key=='~':
    userCommand()
  if key=='p':
    line = not line
  if key=='#':
    reload(Terrain)
  if key=='o':
    enableAtmosphere = not enableAtmosphere
  if key=='?':
    print open('help').read()
  keys.add(key)

def keyboardUp(key,x,y):
  if key in keys:
    keys.remove(key)

def mouse(button,state,x,y):
  global mouseX,mouseY
  glut.glutWarpPointer(windowWidth/2,windowHeight/2)
  mouseX = windowWidth/2
  mouseY = windowHeight/2

def userCommand():
  command = raw_input('>>> ')
  while (command not in ['continue','exit']):
    try:
      exec(command,globals())
    except Exception as e:
      print "Exception:",e
    command = raw_input('>>> ')

glut.glutInit()
logging.info("Requesting OpenGL 4.2")
glut.glutInitContextVersion(4, 2);
glut.glutInitContextFlags(glut.GLUT_FORWARD_COMPATIBLE);
glut.glutInitContextProfile(glut.GLUT_CORE_PROFILE);
glut.glutInitDisplayMode(glut.GLUT_DOUBLE | glut.GLUT_RGBA | glut.GLUT_DEPTH)
glut.glutInitWindowSize(512,512);
glut.glutCreateWindow("PM4")
gl.glEnable(gl.GL_DEPTH_TEST)
gl.glPolygonMode(gl.GL_FRONT_AND_BACK,gl.GL_FILL);
gl.glEnable(gl.GL_BLEND)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA);
glut.glutReshapeFunc(reshape)
glut.glutDisplayFunc(display)
glut.glutKeyboardFunc(keyboard)
glut.glutMouseFunc(mouse)
glut.glutKeyboardUpFunc(keyboardUp)
glut.glutTimerFunc(1000/60, timer, 60)
glut.glutPassiveMotionFunc(mouseMotion)
logging.info("Obtained OpenGL "+gl.glGetString(gl.GL_VERSION))

import RenderStage

from Shaders import *
import Camera
import Texture
#import Marker
import Terrain
import noiseG
noiseG.load(setUniform)
#import Road
projection = perspective( 60.0, 1, 0.3, 8000.0 )
setUniform('projection',projection)
setUniform('fogLevel',8.0)
setUniform('maxFog',1000.0)
#import Forest

import Shadows
import postrender
import Sky
#import grass

camera = Camera.Camera(np.array([0,1e4,0]))
camera.radiusCentre = np.array([0,-Re,0])
camera.minRadius = Re
camera.render()
Shadows.lockCam = camera
#camera.locked = True
#for i in xrange(-10,10):
#  for j in xrange(-10,10):
#    Marker.addMarker(400*np.array([i,0,j]))
#Marker.freeze()

renderStages = [RenderStage.RenderStage(),
                RenderStage.RenderStage(),
                RenderStage.RenderStage(),
                RenderStage.RenderStage(final_stage=True)
                ]
print "Initialisation finished."
glut.glutMainLoop()
